'use strict';

const uuid = require('node-uuid');

const mqttEmitterRPC = require('../lib/mqtt-emitter-rpc');

const TOPIC_AUDIO_PLAY = 'sound_manager/play';
const TOPIC_AUDIO_BPLAY = 'sound_manager/break';

const TOPIC_AUDIO_TERMINATED = 'sound_manager/+soundId/terminate';
const TOPIC_AUDIO_COMPLETE = 'sound_manager/+soundId/complete';
const TOPIC_AUDIO_INVOKE_ERROR = 'sound_manager/+soundId/error';

const TOPIC_AUDIO_STOP_ALL = 'sound_manager/stop_all';


class AudioPlayTask {

  run(args, callback) {
    var soundId = uuid.v4();
    var file = args[0];
    var type = args[1].type;
    var cache = args[1].cache;

    var topic = TOPIC_AUDIO_PLAY;
    if (type === 'break') {
      topic = TOPIC_AUDIO_BPLAY;
    }

    this.callback = callback;
    this.soundId = soundId;
    this.rpc = mqttEmitterRPC({
      topic, payload: { file, soundId, cache },
      emitter: this.app.mqttEmitter,
      related: this.isRelated.bind(this)
    }, [
      TOPIC_AUDIO_COMPLETE,
      TOPIC_AUDIO_TERMINATED,
      TOPIC_AUDIO_INVOKE_ERROR
    ], this.onResult.bind(this));
  }

  isRelated(payload, params) {
    return params.soundId === this.soundId;
  }

  onResult(err, payload, params, topic, topicPattern) {
    if (topicPattern === TOPIC_AUDIO_INVOKE_ERROR)
      return this.callback(payload);
    this.callback(null, payload);
  }

  onCancel() {
    this.rpc.cancel();
    this.app.mqttEmitter.publish(TOPIC_AUDIO_STOP_ALL);
  }
}

module.exports = AudioPlayTask;
