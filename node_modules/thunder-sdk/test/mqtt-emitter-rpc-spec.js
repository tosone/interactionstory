const mqtt = require('mqtt');
const assert = require('assert');
const NodeMQTTEmitter = require('../lib/node-mqtt-emitter');
const mqttEmitterRPC = require('../lib/mqtt-emitter-rpc');

var mqttClient = mqtt.connect('mqtt://localhost');
var mqttEmitter = NodeMQTTEmitter(mqttClient);

describe('mqtt emitter rpc', function () {

  describe('basic', function () {

    before(function () {
      mqttEmitter.on('aaa', function () {
        mqttEmitter.publish('bbb');
      });
    });

    after(function () {
      mqttEmitter.removeAllListeners('aaa');
    });

    it('emitter should listen topics', function (done) {
      mqttEmitter.on('a/+id', function response(payload, params, topic, topicPattern) {
        assert(params.id === '1');
        mqttEmitter.removeListener('a/+id', response);
        mqttClient.publish('a/2', JSON.stringify({b:2}));
        setTimeout(done, 10);
      });
      mqttEmitter.publish('a/1', JSON.stringify({b:2}));
    });

    it('should not failed on minimal arguments', function (done) {
      mqttEmitterRPC({
        topic: 'aaa',
        emitter: mqttEmitter,
        related: function () {return true}
      }, ['bbb'], function (err, payload, params, topic) {
        assert(topic === 'bbb');
        done();
      });
    });

  });

  describe('repeat', function () {

    before(function () {
      mqttEmitter.on('aaa', function () {
        mqttEmitter.publish('bbb');
      });
    });

    after(function () {
      mqttEmitter.removeAllListeners('aaa');
    });

    it('should success on minimal arguments', function (done) {
      mqttEmitterRPC({
        topic: 'aaa',
        emitter: mqttEmitter,
        related: function () {return true}
      }, ['bbb'], function (err, payload, params, topic) {
        assert(topic === 'bbb');
        done();
      });
    });

  });

  describe('multiple reply topic', function () {

    before(function () {
      var counter = 0;
      mqttEmitter.on('aaa', function () {
        if (counter === 0) {
          mqttEmitter.publish('bbb');
          counter++;
        } else {
          mqttEmitter.publish('ccc');
        }
      });
    });

    after(function () {
      mqttEmitter.removeAllListeners('aaa');
    });

    it('should have error when error topic emitted', function (done) {
      mqttEmitterRPC({
        topic: 'aaa',
        emitter: mqttEmitter,
        related: function () {return true}
      }, ['bbb', 'ccc'], function (err, payload, params, topic) {
        assert(topic === 'bbb', `first topic is not bbb: ${topic}`);

        mqttEmitterRPC({
          topic: 'aaa',
          emitter: mqttEmitter,
          related: function () {return true}
        }, ['bbb', 'ccc'], function (err, payload, params, topic) {
          assert(topic === 'ccc', 'second topic is not ccc')
          done();
        });
      });
    });

  });

  describe('json handling', function () {

    before(function () {
      mqttEmitter.on('aaa', function (payload) {
        mqttEmitter.publish('bbb', payload);
      });
    });

    after(function () {
      mqttEmitter.removeAllListeners('aaa');
    });

    it('should echo payload', function (done) {
      mqttEmitterRPC({
        topic: 'aaa',
        payload: { ok: true },
        emitter: mqttEmitter,
        related: function () {return true}
      }, ['bbb'], function (err, payload, params) {
        assert(payload.ok);
        done();
      });
    });

  });

  describe('correlaction case', function () {

    before(function () {
      mqttEmitter.on('aaa', function () {
        mqttEmitter.publish('bbb/456', JSON.stringify({
          correlactionId: 456,
          ok: false
        }));
        setTimeout(function () {
          mqttEmitter.publish('bbb/123', JSON.stringify({
            correlactionId: 123,
            ok: true
          }));
        }, 10);
      });
    });

    after(function () {
      mqttEmitter.removeAllListeners('aaa');
    });

    it('should only reply related message', function (done) {
      mqttEmitterRPC({
        topic: 'aaa',
        emitter: mqttEmitter,
        related: function (payload, params) {
          return payload.correlactionId === 123 && params.id === '123'
        }
      }, ['bbb/+id'], function (err, payload, params) {
        assert(payload.ok);
        done();
      });
    });

  });

});
